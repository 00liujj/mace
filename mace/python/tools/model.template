//
// Copyright (c) 2017 XiaoMi All rights reserved.
// Generated by the mace converter.  DO NOT EDIT!
//

{% if mode == 0 %}
#include <vector>
#include "mace/core/public/mace.h"

namespace mace {
namespace {{tag}} {

{% if tensor_info.data_type != 'DT_UINT8' %} alignas(4) {% endif %} unsigned char {{ tensor_info.name }}[] = {
{% for d in tensor_info.data %}{{"0x%02X, " % d }}{%endfor%}
};

void Create{{tensor.name}}(std::vector<mace::ConstTensor> &tensors) {
  tensors.emplace_back(mace::ConstTensor(
      {{ tensor.name|tojson }}, {{ tensor.name }},
      { {{ tensor.dims|join(', ') }} }, {{ tensor.data_type }}, {{ tensor.node_id }}));
}

}  // namespace {{tag}}
}  // namespace mace

{% elif mode == 1 %}
#include <vector>
#include <string>
#include "mace/core/public/mace.h"

namespace {
void UpdateOp(mace::OperatorDef &op,
              const std::string &name,
              const std::string &type,
              const std::vector<std::string> &inputs,
              const std::vector<std::string> &outputs,
              const std::vector<mace::DataType> &output_types,
              uint32_t node_id) {
  op.set_name(name);
  op.set_type(type);
  op.set_input(inputs);
  op.set_output(outputs);
  op.set_output_type(output_types);
  op.set_node_id(node_id);
}
}

namespace mace {
namespace {{tag}} {

{% for i in range(start, end) %}

void CreateOperator{{i}}(mace::OperatorDef &op) {
  mace::Argument *arg = nullptr;
  {% for arg in net.op[i].arg %}

  arg = op.add_arg();
  arg->set_name({{ arg.name|tojson }});

  {%- if arg.HasField('f') %}
  arg->set_f({{ arg.f }});
  {%- endif %}
  {%- if arg.HasField('i') %}
  arg->set_i({{ arg.i }});
  {%- endif %}
  {%- if arg.HasField('s') %}
  arg->set_s({{ arg.s|tojson }});
  {%- endif %}

  {% if arg.floats|length != 0 %}
  arg->set_floats({ {{ arg.floats|join(', ') }} });
  {% endif %}
  {% if arg.ints|length != 0 %}
  arg->set_ints({ {{ arg.ints|join(', ') }} });
  {% endif %}
  {% if arg.strings|length != 0 %}
  arg->set_strings({ {{ arg.strings|stringfy() }} });
  {% endif %}
  {% endfor %}

  {% if net.op[i].HasField('mem_id') %}
  op.set_mem_id({{net.op[i].mem_id}});
  {% endif %}

  {% for shape in net.op[i].output_shape %}
	{% if shape.dims | length > 0 %}
  op.add_output_shape(mace::OutputShape({ {{ shape.dims|join(', ') }} }));
	{% endif %}
  {% endfor %}

  std::vector<int> output_types_int({ {{ net.op[i].output_type | join(', ') }} });
  std::vector<mace::DataType> output_types({{ net.op[i].output_type | length }});
  for (int k = 0; k < {{ net.op[i].output_type | length }}; ++k) {
    output_types[k] = static_cast<mace::DataType>(output_types_int[k]);
  }
  UpdateOp(op, {{ net.op[i].name|tojson }}, {{ net.op[i].type|tojson}},
          { {{ net.op[i].input|stringfy }} },
          { {{ net.op[i].output|stringfy }} },
          output_types,
          {{ net.op[i].node_id }});

  {% if runtime == 'dsp' %}
    op.set_padding({{ net.op[i].padding }});
    {% if net.op[i].node_input | length > 0 %}
    std::vector<int> input_node_ids({ {{ net.op[i].node_input | map(attribute='node_id') | join(', ') }} });
    std::vector<int> input_output_ports({ {{ net.op[i].node_input | map(attribute='output_port') | join(', ')}} });

    for (size_t i = 0; i < {{ net.op[i].node_input | length }}; ++i) {
      mace::NodeInput input(input_node_ids[i], input_output_ports[i]);
      op.add_node_input(input);
    }
    {% endif %}
    {% if net.op[i].out_max_byte_size | length > 0 %}
    std::vector<int> out_max_byte_sizes {{ net.op[i].out_max_byte_size | replace('[', '{') | replace(']', '}') }};
    for (size_t i = 0; i < {{ net.op[i].out_max_byte_size | length }}; ++i) {
      op.add_out_max_byte_size(out_max_byte_sizes[i]);
    }
    {% endif %}
  {% endif %}

}

{% endfor %}

}  // namespace {{tag}}
}  // namespace mace

{% else %}
#include <vector>
#include <string>
#include "mace/core/public/mace.h"

namespace mace {
namespace {{tag}} {

{% for tensor in tensors %}
extern void Create{{ tensor.name }}(std::vector<mace::ConstTensor> &tensors);
{% endfor %}


{% for i in range(net.op|length) %}
extern void CreateOperator{{i}}(mace::OperatorDef &op);
{% endfor %}

}  // namespace {{ tag }}
}  // namespace mace


namespace {

{% if net.arg|length != 0 %}
void CreateNetArg(mace::NetDef &net_def) {
  net_def.mutable_arg().reserve({{ net.arg|length }});
  mace::Argument *arg = nullptr;
  {% for arg in net.arg %}

  arg = net_def.add_arg();
  arg->set_name({{ arg.name|tojson }});

  {%- if arg.HasField('f') %}
  arg->set_f({{ arg.f }});
  {% endif %}

  {%- if arg.HasField('i') %}
  arg->set_i({{ arg.i }});
  {% endif %}

  {%- if arg.HasField('s') %}
  arg->set_s({{ arg.s|tojson }});
  {% endif %}

  {% if arg.floats|length != 0 %}
  arg->set_floats({ {{ arg.floats|join(', ') }} });
  {% endif %}
  {% if arg.ints|length != 0 %}
  arg->set_ints({ {{ arg.ints|join(', ') }} });
  {% endif %}
  {% if arg.strings|length != 0 %}
  arg->set_strings({ {{ arg.strings|stringfy() }} });
  {% endif %}

  {% endfor %}
}
{% endif %}

{% if net.output_info | length > 0 %}
void CreateOutputInfo(mace::NetDef &net_def) {
	std::vector<std::vector<int>> dims { {{net.output_info | map(attribute='dims') | join(', ') | replace('[', '{') | replace(']', '}') }} };

  std::vector<int> data_types_int { {{ net.output_info | map(attribute='data_type') | join(', ') }} };
  std::vector<mace::DataType> data_types({{ net.output_info | length }});
  for (int k = 0; k < {{ net.output_info | length }}; ++k) {
    data_types[k] = static_cast<mace::DataType>(data_types_int[k]);
  }
  net_def.mutable_output_info().resize({{ net.output_info | length }});
  for (int i = 0; i < {{ net.output_info | length }}; ++i) {
    net_def.mutable_output_info()[i].set_data_type(data_types[i]);
    net_def.mutable_output_info()[i].set_dims(dims[i]);
  }
}
{% endif %}

void CreateOperators(std::vector<mace::OperatorDef> &ops) {
  ops.resize({{ net.op|length }});
  {% for i in range(net.op|length) %}

  mace::{{tag}}::CreateOperator{{i}}(ops[{{i}}]);
  {% endfor %}

}

void CreateTensors(std::vector<mace::ConstTensor> &tensors) {
  tensors.reserve({{ net.tensors|length }});

  {% for tensor in net.tensors %}

  mace::{{tag}}::Create{{tensor.name}}(tensors);
  {% endfor %}

}


{% if net.mem_arena.mem_block|length != 0 %}
void CreateMemoryArena(mace::MemoryArena &mem_arena) {
  std::vector<mace::MemoryBlock> &mem_block = mem_arena.mutable_mem_block();
  mem_block.reserve({{ net.mem_arena.mem_block|length }});

  {% for mem_blk in net.mem_arena.mem_block %}
  mem_block.emplace_back(mace::MemoryBlock({{ mem_blk.mem_id }},
                                           {{mem_blk.x}},
                                           {{mem_blk.y}}));
  {% endfor %}

}
{% endif %}

}

namespace mace {
namespace {{tag}} {

NetDef CreateNet() {
  NetDef net_def;
  net_def.set_name("{{ net.name}}");
  net_def.set_version("{{ net.version }}");

  {% if net.arg|length != 0 %}
  CreateNetArg(net_def);
  {% endif %}

  CreateOperators(net_def.mutable_op());

  CreateTensors(net_def.mutable_tensors());

  {% if net.mem_arena.mem_block|length != 0 %}
  CreateMemoryArena(net_def.mutable_mem_arena());
  {% endif %}

  {% if net.output_info | length > 0 %}
  CreateOutputInfo(net_def);
  {% endif %}

  return net_def;
}

const std::string ModelChecksum() {
  return {{ model_pb_checksum|tojson }};
}

}  // namespace {{tag}}
}  // namespace mace
{% endif %}

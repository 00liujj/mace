// Copyright 2018 Xiaomi, Inc.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This is a generated file. DO NOT EDIT!

#include <vector>
#include <string>

#include "mace/core/macros.h"
#include "mace/public/mace.h"
#include "mace/utils/env_time.h"
#include "mace/utils/logging.h"

namespace mace {
{% if model_type == 'source' %}
namespace {{tag}} {

{% for tensor in tensors %}
extern void CreateTensor{{ tensor.id }}(mace::ConstTensor *tensor);
{% endfor %}


{% for i in range(net.op|length) %}
extern void CreateOperator{{i}}(mace::OperatorDef *op);
{% endfor %}

}  // namespace {{ tag }}

namespace {

{% if net.arg|length != 0 %}
void CreateNetArg(mace::NetDef &net_def) {
  mace::Argument *arg = nullptr;
  {% for arg in net.arg %}

  arg = net_def.add_arg();
  arg->set_name({{ arg.name|tojson }});

  {%- if arg.HasField('f') %}
  arg->set_f({{ arg.f }});
  {% endif %}

  {%- if arg.HasField('i') %}
  arg->set_i({{ arg.i }});
  {% endif %}

  {%- if arg.HasField('s') %}
  arg->set_s({{ arg.s|tojson }});
  {% endif %}

  {% for float_value in arg.floats %}
  arg->add_floats({ {{ float_value }} });
  {% endfor %}
  {% for int_value in arg.ints %}
  arg->add_ints({ {{ int_value }} });
  {% endfor %}
  {% for str_value in arg.strings %}
  arg->add_strings({ {{ str_value }} });
  {% endfor %}

  {% endfor %}
}
{% endif %}

{% if net.output_info | length > 0 %}
void CreateOutputInfo(mace::NetDef &net_def) {
  std::vector<std::vector<int>> dims { {{net.output_info | map(attribute='dims') | join(', ') | replace('[', '{') | replace(']', '}') }} };

  std::vector<int> data_types_int { {{ net.output_info | map(attribute='data_type') | join(', ') }} };
  std::vector<mace::DataType> data_types({{ net.output_info | length }});
  for (int k = 0; k < {{ net.output_info | length }}; ++k) {
    data_types[k] = static_cast<mace::DataType>(data_types_int[k]);
  }
  for (int i = 0; i < {{ net.output_info | length }}; ++i) {
    net_def.add_output_info();
    net_def.mutable_output_info(i)->set_data_type(data_types[i]);
    for (int j = 0; j < (int)dims[i].size(); ++j) {
      net_def.mutable_output_info(i)->add_dims(dims[i][j]);
    }
  }
}
{% endif %}

void CreateOperators(mace::NetDef *net_def) {
  MACE_LATENCY_LOGGER(1, "Create operators");

  {% for i in range(net.op|length) %}
  mace::{{tag}}::CreateOperator{{i}}(net_def->add_op());
  {% endfor %}
}

void CreateTensors(mace::NetDef *net_def) {
  MACE_LATENCY_LOGGER(1, "Create tensors");

  {% for tensor in tensors %}
  mace::{{tag}}::CreateTensor{{tensor.id}}(net_def->add_tensors());
  {% endfor %}
}

{% if net.mem_arena.mem_block|length != 0 %}
void CreateMemoryArena(mace::MemoryArena *mem_arena) {
  {% for i in range(net.mem_arena.mem_block|length) %}

  mace::MemoryBlock* mem_block{{i}} = mem_arena->add_mem_block();
  mem_block{{i}}->set_mem_id({{net.mem_arena.mem_block[i].mem_id}});
  mem_block{{i}}->set_x({{net.mem_arena.mem_block[i].x}});
  mem_block{{i}}->set_y({{net.mem_arena.mem_block[i].y}});

  {% endfor %}
}
{% endif %}


}  // namespace
{% endif %}

namespace {{tag}} {

NetDef CreateNet(const std::vector<unsigned char> &model_pb = {}) {
  MACE_LATENCY_LOGGER(1, "Create net {{ net.name }}");

  NetDef net_def;

  {% if model_type == 'source' %}
  MACE_UNUSED(model_pb);
  net_def.set_name("{{ net.name}}");
  net_def.set_version("{{ net.version }}");

  CreateOperators(&net_def);
  CreateTensors(&net_def);

  {% if net.arg|length != 0 %}
  CreateNetArg(net_def);
  {% endif %}
  {% if net.mem_arena.mem_block|length != 0 %}
  CreateMemoryArena(net_def.mutable_mem_arena());
  {% endif %}
  {% if net.output_info | length > 0 %}
  CreateOutputInfo(net_def);
  {% endif %}

  {% else %}

  net_def.ParseFromArray(&model_pb[0], model_pb.size());
  {% endif %}

  return net_def;
}

const std::string ModelName() {
  return {{ tag|tojson }};
}

const std::string ModelChecksum() {
  return {{ checksum|tojson }};
}

const std::string ModelBuildTime() {
  return {{ build_time|tojson }};
}

const std::string ModelBuildOptions() {
  return {{ "runtime: {}, obfuscate: {}, embed_model_data: {}, winograd: {}"
        .format(runtime, obfuscate, embed_model_data, winograd_conv)|tojson }};
}

}  // namespace {{tag}}
}  // namespace mace

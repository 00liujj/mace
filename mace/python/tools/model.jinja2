//
// Copyright (c) 2017 XiaoMi All rights reserved.
// Generated by the mace converter.  DO NOT EDIT!
//

#include <vector>
#include <string>

#include "mace/public/mace.h"
#include "mace/utils/env_time.h"
#include "mace/utils/logging.h"

namespace mace {
namespace {{tag}} {

{% for tensor in tensors %}
extern void CreateTensor{{ tensor.id }}(std::vector<mace::ConstTensor> *tensors,
                                        const unsigned char *model_data);
{% endfor %}


{% for i in range(net.op|length) %}
extern void CreateOperator{{i}}(mace::OperatorDef *op);
{% endfor %}

}  // namespace {{ tag }}

namespace {

{% if net.arg|length != 0 %}
void CreateNetArg(mace::NetDef &net_def) {
  net_def.mutable_arg().reserve({{ net.arg|length }});
  mace::Argument *arg = nullptr;
  {% for arg in net.arg %}

  arg = net_def.add_arg();
  arg->set_name({{ arg.name|tojson }});

  {%- if arg.HasField('f') %}
  arg->set_f({{ arg.f }});
  {% endif %}

  {%- if arg.HasField('i') %}
  arg->set_i({{ arg.i }});
  {% endif %}

  {%- if arg.HasField('s') %}
  arg->set_s({{ arg.s|tojson }});
  {% endif %}

  {% if arg.floats|length != 0 %}
  arg->set_floats({ {{ arg.floats|join(', ') }} });
  {% endif %}
  {% if arg.ints|length != 0 %}
  arg->set_ints({ {{ arg.ints|join(', ') }} });
  {% endif %}
  {% if arg.strings|length != 0 %}
  arg->set_strings({ {{ arg.strings|stringfy() }} });
  {% endif %}

  {% endfor %}
}
{% endif %}

{% if net.output_info | length > 0 %}
void CreateOutputInfo(mace::NetDef &net_def) {
	std::vector<std::vector<int>> dims { {{net.output_info | map(attribute='dims') | join(', ') | replace('[', '{') | replace(']', '}') }} };

  std::vector<int> data_types_int { {{ net.output_info | map(attribute='data_type') | join(', ') }} };
  std::vector<mace::DataType> data_types({{ net.output_info | length }});
  for (int k = 0; k < {{ net.output_info | length }}; ++k) {
    data_types[k] = static_cast<mace::DataType>(data_types_int[k]);
  }
  net_def.mutable_output_info().resize({{ net.output_info | length }});
  for (int i = 0; i < {{ net.output_info | length }}; ++i) {
    net_def.mutable_output_info()[i].set_data_type(data_types[i]);
    net_def.mutable_output_info()[i].set_dims(dims[i]);
  }
}
{% endif %}

void CreateOperators(std::vector<mace::OperatorDef> *ops) {
  MACE_LATENCY_LOGGER(1, "Create operators");

  ops->resize({{ net.op|length }});

  {% for i in range(net.op|length) %}
  mace::{{tag}}::CreateOperator{{i}}(&ops->at({{i}}));
  {% endfor %}
}

void CreateTensors(std::vector<mace::ConstTensor> *tensors,
                   const unsigned char *model_data) {
  MACE_LATENCY_LOGGER(1, "Create tensors");
  tensors->reserve({{ net.tensors|length }});

  {% for tensor in tensors %}
  mace::{{tag}}::CreateTensor{{tensor.id}}(tensors, model_data);
  {% endfor %}
}


{% if net.mem_arena.mem_block|length != 0 %}
void CreateMemoryArena(mace::MemoryArena *mem_arena) {
  std::vector<mace::MemoryBlock> &mem_block = mem_arena->mutable_mem_block();
  mem_block.reserve({{ net.mem_arena.mem_block|length }});

  {% for mem_blk in net.mem_arena.mem_block %}
  mem_block.emplace_back(mace::MemoryBlock({{ mem_blk.mem_id }},
                                           {{mem_blk.x}},
                                           {{mem_blk.y}}));
  {% endfor %}

}
{% endif %}

}  // namespace

namespace {{tag}} {

NetDef CreateNet(const unsigned char *model_data) {
  MACE_LATENCY_LOGGER(1, "Create net {{ net.name }}");
  NetDef net_def;
  net_def.set_name("{{ net.name}}");
  net_def.set_version("{{ net.version }}");

  {% if net.arg|length != 0 %}
  CreateNetArg(net_def);
  {% endif %}

  CreateOperators(&net_def.mutable_op());

  CreateTensors(&net_def.mutable_tensors(), model_data);

  {% if net.mem_arena.mem_block|length != 0 %}
  CreateMemoryArena(&net_def.mutable_mem_arena());
  {% endif %}

  {% if net.output_info | length > 0 %}
  CreateOutputInfo(net_def);
  {% endif %}

  return net_def;
}

const std::string ModelChecksum() {
  return {{ model_pb_checksum|tojson }};
}

}  // namespace {{tag}}
}  // namespace mace
